% The contents of this file is 
% Copyright (c) 2009-  Charles R. Severance, All Righs Reserved

\chapter{Perch\'{e} dovresti imparare a scrivere programmi?}

Scrivere programmi (o programmare) \`{e} un'attivit\`{a} molto creativa e gratificante. Puoi scrivere programmi per molte ragioni che vanno dal guadagnarsi da vivere al risolvere complessi programmi di analisi dei dati al divertirsi aiutando qualcuno a risolvere un problema. Questo libro d\`{a} per scontato che \emph{ognuno} abbia bisogno di sapere come programmare e che una volta imparato a farlo,  trover\`{a} come impiegare questa nuova abilit\`{a}.


Siamo circondati nella vita quotidiana da computers, siano essi portatili o cellulari. Possiamo pensare a questi computers come i nostri {``}assistenti personali'' che possono farsi carico di molte cose al nostro posto. L'hardware nel nostro computer \`{e} essenzialmente costruito per porci continuamente la stessa domanda, {``}Cosa vuoi che faccia ora?''

\beforefig
\centerline{\includegraphics[height=1.00in]{figs2/pda.eps}}
\afterfig

I programmatori aggiungono un sistema operativo e un insieme di applicazioni all'hardware, e noi ci troviamo con un assistente personale digitale \footnote{anche detto PDA, Personal Digital Assistant}, come uno smartphone, che \`{e} piuttosto utile e capace di svolgere molti compiti diversi.


I nostri computers sono veloci e hanno grandi quantit\`{a} di memoria e potrebbero essere molto utili per noi se solo conoscessimo il linguaggio con cui spiegare al computer cosa noi vorremmo {``}fare dopo''. Se conoscessimo questo linguaggio potremmo dire al computer di compiere azioni ripetitive per conto nostro. Curiosamente, i tipi di cose che i computers fanno meglio sono le cose che noi umani troviamo noiose e alienanti.


Per esempio, osserva i primi tre paragrafi di questo capitolo e dimmi qual \`{e} la parola pi\`{u} usata e quante volte essa \`{e} ripetuta. Bench\'{e} tu sia in grado di leggere e capire le parole in pochi secondi, contarle \`{e} piuttosto difficile perch\'{e} non \`{e} il tipo di compito per cui la mente umana \`{e} progettata. Per un computer \`{e} vero il contrario, leggere e capire un testo scritto su un pezzo di carta \`{e} difficile mentre contare le parole e dire quante volte ricorre la parola pi\`{u} usata, \`{e} un compito molto agevole:

\beforeverb
\begin{verbatim}
python words.py
Enter file:words.txt
to 16
\end{verbatim}
\afterverb
%
Il nostro {``}assistente personale per le analisi delle informazioni'' ci ha detto velocemente che la parola {``}to'' era usata 16 volte nei primi tre paragrafi di questo capitolo \footnote{versione inglese}.


Questo stesso fatto che i computers sono bravi a fare le cose che agli umani riescono peggio \`{e} il motivo per cui dovresti imparare il {``}linguaggio dei computer''. Una volta acquisito questo linguaggio, potrai delegare i compiti noiosi al tuo compagno (il computer), dedicando il tuo tempo alle cose che ti riescono meglio. Tu porterai creativit\`{a}, intuizione e inventiva in questa collaborazione.

\section{Creativit\`{a} e motivazione}

Anche se questo libro non si rivolge a programmatori professionisti, il lavoro di programmatore pu\`{o} essere molto gratificante, sia a livello finanziario che personale. Creare programmi belli, utili ed eleganti affinch\'{e} gli altri ne traggano beneficio \`{e} un'attivit\`{a} molto creativa. Il tuo computer o il tuo PDA spesso contengono molti programmi diversi creati da molti gruppi di programmatori, ciascuno in lotta per ottenere la tua attenzione e il tuo interesse. Essi fanno del loro meglio per venire incontro alle tue necessit\`{a} e fornirti una straordinaria esperienza. 


In alcune situazioni, quando scegli un programma, i programmatori sono ricompensati grazie alla tua scelta.


Se pensiamo ai programmi come il prodotto creativo di un gruppo di programmatori, forse l'immagine seguente rappresenta una versione pi\`{u} intelligente del tuo PDA:


\beforefig
\centerline{\includegraphics[height=1.00in]{figs2/pda2.eps}}
\afterfig

Per il momento, la nostra motivazione primaria non sar\`{a} fare soldi o soddisfare l'utente finale, ma egoisticamente essere pi\`{u} produttivi nel maneggiare i dati e le informazioni che incontriamo nella nostra vita. Quando inizi per la prima volta, sei contemporaneamente il programmatore e l'utente finale del tuo programma. Man mano che acquisisci competenza come programmatore e la programmazione diventa sempre pi\`{u} un processo creativo per te, potr\`{a} nascere in te il desiderio di programmare per gli altri.

\section{Architettura hardware di un computer}
\index{hardware}
\index{hardware!architecture}

Prima di iniziare ad imparare il linguaggio con cui dare istruzioni ai computers per sviluppare un software, dobbiamo apprendere un paio di nozioni su come i computers sono costruiti. Se smontassi il tuo computer o il tuo cellulare per vedere come sono fatti, troveresti le seguenti parti:

\beforefig
\centerline{\includegraphics[height=2.50in]{figs2/arch.eps}}
\afterfig

La definizione ad alto livello di queste parti \`{e} la seguente:

\begin{itemize}

\item The {\bf Central Processing Unit - unit\`{a} di elaborazione centrale} (o CPU) \`{e} quella parte del computer che \`{e} costruita per essere ossessionata dalla domanda {``}Cosa viene dopo?''. Se il tuo computer \`{e} targato a 3.0 Gigahertz, significa che la CPU ti chieder\`{a} {``}Cosa viene dopo?'' tre miliardi di volte al secondo. Dovrai imparare a parlare velocemente per tenere il passo con la CPU.

\item The {\bf Main Memory - memoria principale} \`{e} usata per archiviare informazioni di cui la CPU ha immediato bisogno. La memoria principale \`{e} veloce quasi quanto la CPU. Bisogna ricordare per\`{o} che le informazioni archiviate nella memoria centrale svaniscono quando il computer viene spento.


\item The {\bf Secondary Memory - memoria secondaria} \`{e} usata per archiviare informazioni, ma a differenza della memoria principale \`{e} molto pi\`{u} lenta. Il vantaggio della memoria secondaria \`{e} che pu\`{o} mantenere le informazioni anche quando il computer non \`{e} alimentato. Esempi di memoria secondaria sono gli hard disk o le memorie flash (tipicamente contenute nelle chiavette USB e nei lettori MP3 portatili).

\item The {\bf Input and Output Devices - periferiche di input e output} sono semplicemente il nostro monitor, la tastiera, il mouse, il microfono, gli altoparlanti, il touchpad, ecc. Essi rappresentano i modi che abbiamo di interagire con il computer.

\item 	Oggigiorno la maggior parte dei computers ha anche una
{\bf connessione di rete} per recuperare informazioni da una rete. Possiamo pensare ad una rete come un posto molto lento in cui salvare e recuperare informazioni che potrebbe non essere sempre accessibile. In questo senso la rete \`{e} una forma pi\`{u} lenta e a volte meno affidabile della 
{\bf memoria secondaria}.

\end{itemize}

La maggior parte dei dettagli su come questi componenti interagiscono \`{e} di competenza dei produttori di hardware, ma \`{e} bene avere un lessico comune per parlare di questi componenti in maniera corretta quando scriviamo i nostri programmi.


Come programmatore, il tuo lavoro nell'usare e orchestrare ciascuna di queste risorse per risolvere il problema che devi affrontare e analizzare i dati di cui hai bisogno. Come programmatore, nella maggior parte dei casi {``}parlerai'' alla CPU e le dirai cosa fare dopo. A volte dirai alla CPU di usare la memoria principale, la secondaria, la rete o le periferiche di input/output.



\beforefig
\centerline{\includegraphics[height=2.50in]{figs2/arch2.eps}}
\afterfig

Tu devi essere la persona che risponde alla domanda della CPU {``}Cosa viene dopo?''. Sarebbe per\`{o} molto scomodo rimpicciolirsi ad un'altezza di 5mm e infilarti nel computer cos\`{i} da poter lanciare comandi con una velocit\`{a} di 3 miliardi di operazioni al secondo. Per questo devi scrivere le tue istruzioni in anticipo. Noi chiamiamo queste istruzioni \textbf{programma }e l'atto di scrivere queste istruzioni \textbf{programmazione}.

\section{Capire la programmazione}

Nel proseguo di questo libro cercheremo di trasformarti in una persona esperta nella tecnica di programmazione. Alla fine sarai un \textbf{programmatore }--- forse non un programmatore professionista, ma almeno avrai la capacit\`{a} di affrontare un problema di analisi dei dati e sviluppare un programma per risolverlo.

\index{problem solving}

Per certi versi, hai bisogno di due abilit\`{a} per essere un programmatore:

\begin{itemize}

\item In primo luogo \`{e} necessario conoscere il linguaggio di programmazione (Python) - \`{e} necessario conoscerne il vocabolario e la grammatica. \`{E} necessario che tu sia in grado di pronunciare correttamente le parole in questo nuovo linguaggio e di costruire {``}frasi'' sintatticamente corrette in questo nuovo linguaggio.


\item In secondo luogo \`{e} necessario {``}raccontare una storia''. Nello scrivere una storia, si combinano parole e frasi per dare un'idea al lettore. C'\`{e} tecnica e arte nella costruzione del racconto e la capacit\`{a} di scrivere una storia si migliora stilando qualche testo e ottenendone un feedback. Nella programmazione, il nostro programma \`{e} la {``}storia'' e il problema che si sta tentando di risolvere \`{e} {``}l'idea''.

\end{itemize}

Una volta imparato un linguaggio di programmazione come Python, troverai molto pi\`{u} facile imparare una seconda lingua di programmazione come JavaScript o C + +. Il nuovo linguaggio di programmazione ha un vocabolario e una grammatica molto diversi, ma una volta appresa la capacit\`{a} di risolvere problemi (\emph{problem solving)}, essa sar\`{a} la stessa per tutti i linguaggi di programmazione.

Imparerai il {``}vocabolario'' e le {``}frasi'' di Python abbastanza rapidamente. Ci vorr\`{a} pi\`{u} tempo prima di essere in grado di scrivere un programma coerente per risolvere un nuovo problema. Noi insegniamo la programmazione nello stesso modo in cui insegniamo a scrivere. Iniziamo a leggere e spiegare i programmi, poi scriviamo programmi semplici e via via programmi sempre pi\`{u} complessi. Ad un certo punto si {``}raggiunge l'illuminazione'' e si riescono a vedere i modelli ed a comprendere pi\`{u} naturalmente come affrontare un problema e scrivere un programma che lo risolva. Una volta arrivato a quel punto, la programmazione diventa un processo molto piacevole e creativo.

Iniziamo con il vocabolario e la struttura dei programmi Python. Sii paziente quando i semplici esempi ti ricorderanno i tempi in cui iniziasti a leggere.

\section{Parole e frasi}
\index{programming language}
\index{language!programming}

A differenza dei linguaggi umani, il vocabolario Python \`{e} in realt\`{a} piuttosto ristretto. Questo {``}vocabolario'' \`{e} rappresentato da parole dette \textbf{{``}parole riservate''}. Esse hanno un significato molto speciale per Python. Quando Python incontra queste parole in un programma, esse hanno uno ed un solo significato per Python. In seguito, quando scriverai i tuoi programmi, inventerai le tue parole a cui darai un significato e chiamerai \textbf{variabili}. Avrai grande libert\`{a} nella scelta dei nomi per le variabili, ma non \`{e} possibile utilizzare una qualsiasi delle parole riservate di Python come nome per una variabile.


In un certo senso, quando alleniamo un cane, vorremmo usare parole speciali come, {``}seduto'', {``}fermo'', e {``}afferra''. Anche quando parli ad un cane e di non utilizzi delle parole riservate, il cane ti guarda con lo sguardo perplesso e confuso finch\'{e} non usi una parola riservata. Ad esempio, se dici {``}Vorrei che pi\`{u} persone camminassero per migliorare la loro salute generale'', quello che la maggior parte dei cani probabilmente sente \`{e}: {``}bla bla bla \textbf{camminare }bla bla bla bla''. Questo perch\'{e} {``}camminare'' \`{e} una parola riservata in lingua-cane. Molti potrebbero insinuare che la lingua tra umani e gatti non ha parole riservate\footnote{	 http://xkcd.com/231/} .


Le parole riservate nella lingua con cui gli umani parlano con Python sono:

\beforeverb
\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}
\afterverb
%
A differenza di un cane, Python \`{e} perfettamente addestrato e se dici {``}try'', Python eseguir\`{a} {``}try'' tutte le volte senza fallire.


Impareremo queste parole riservate e come esse sono utilizzati a tempo debito, per ora ci concentreremo sull'equivalente Python di {``}parlare'' (in una lingua umano-cane). La cosa bella di conversare con Python \`{e} che possiamo anche dirgli che cosa dire passandogli un messaggio tra virgolette:

\beforeverb
\begin{verbatim}
print 'Hello world!'
\end{verbatim}
\afterverb

Abbiamo scritto la nostra prima frase sintatticamente corretta in Python. La nostra frase inizia con la parola riservata print seguita da una stringa di testo scelta da noi racchiusa da apici semplici.

\section{Dialogare con Python}

Ora che conosciamo una semplice frase in Python, abbiamo bisogno di sapere come iniziare una conversazione con Python per testare le nostre nuove abilit\`{a} linguistiche.

Prima di poter conversare con Python, devi prima installare Python sul tuo computer e imparare come lanciarlo. Scenderemmo troppo in dettaglio per questo capitolo, quindi ti suggerisco di consultare \url{www.pythonlearn.com} dove ho lasciato istruzioni dettagliate e degli screencast su come installare e avviare Python su sistemi Macintosh e Windows. Ad un certo punto ti troverai su una finestra terminale o sul command prompt di Windows, scriverai \textbf{python }e l'interprete Python verr\`{a} lanciato in modalit\`{a} interattiva, mostrandos\`{i} pi\`{u} o meno cos\`{i}:

\index{interactive mode}

\beforeverb
\begin{verbatim}
Python 2.6.1 (r261:67515, Jun 24 2010, 21:47:49) 
[GCC 4.2.1 (Apple Inc. build 5646)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> 
\end{verbatim}
\afterverb
%
Il  {\tt >>>} \`{e} il modo dell'interprete Python di chiederti {``}Cosa vuoi che faccia adesso?''. Python \`{e} pronto a conversare con te. Tutto quello che devi sapere \`{e} come parlare la lingua di Python, in seguito potrai iniziare a colloquiare.

Diciamo, per esempio, che non conosci nemmeno le parole o le frasi pi\`{u} elementari in Python. Potresti usare la frase standard the usano gli astronauti quando atterrano su un lontano pianeta e cercano di comunicare con i nativi del luogo:

\beforeverb
\begin{verbatim}
>>> Io vengo in pace, per favore portatemi al vostro capo
  File "<stdin>", line 1
   Io vengo in pace, per favore portatemi al vostro capo
               ^
SyntaxError: invalid syntax
>>> 
\end{verbatim}
\afterverb
%
Non si sta mettendo bene. A meno che tu non pensi a qualcosa velocemente, gli abitanti del pianeta sono propensi ad infilzarti con le loro lance, metterti su uno spiedo, arrostirti su un fuoco e mangiarti per cena.


Fortunatamente ti sei portato una copia di questo libro e sfogliandolo fino a questa pagina scrivi ancora:

\beforeverb
\begin{verbatim}
>>> print 'Ciao mondo!'
Ciao mondo!
\end{verbatim}
\afterverb
%
Va molto meglio, quindi tenti di comunicare ancora:

\beforeverb
\begin{verbatim}
>>> print 'Tu devi essere il dio leggendario che viene dal cielo'
Tu devi essere il dio leggendario che viene dal cielo
>>> print 'Ti abbiamo aspettato per un lungo tempo'
Ti abbiamo aspettato per un lungo tempo
>>> print 'La nostra leggenda narra che sarai molto saporito con la mostarda'
La nostra leggenda narra che sarai molto saporito con la mostarda
>>> print 'Avremo una festa stasera a meno che tu non dici
  File "<stdin>", line 1
    print 'Avremo una festa stasera a meno che tu non dici
                                                                                         ^
SyntaxError: EOL while scanning string literal
>>> 
\end{verbatim}
\afterverb
%
La conversazione stava andando bene, poi hai commesso un errore piccolissimo con il linguaggio e sono rispuntate le lance.


A questo punto dovresti aver capito che, se da un lato Python \`{e} sorprendentemente complesso, potente e molto puntiglioso sulla sintassi che usi per comunicare con lui, dall'altro lato \emph{non} \`{e} intelligente. Tu stai di fatto avendo una conversazione con te stesso usando la sintassi appropriata.

In un certo senso, quando usi un programma scritto da qualcun altro, la conversazione \`{e} tra te e i programmatori che agiscono da intermediari tra te e Python. Python \`{e} un modo per i programmatori di definire come la conversazione dovrebbe procedere. In un paio di capitoli sarai tu uno di quei programmatori e userai Python per parlare agli utenti del tuo programma.


Prima di terminare la nostra prima conversazione con l'interprete Python, devi conoscere il modo appropriato per dire {``}arrivederci'' agli abitanti del pianeta Python

\beforeverb
\begin{verbatim}
>>> arrivederci
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'arrivederci' is not defined

>>> if you don't mind, I need to leave
  File "<stdin>", line 1
    if you don't mind, I need to leave
             ^
SyntaxError: invalid syntax

>>> quit()
\end{verbatim}
\afterverb
%
Puoi notare che l'errore \`{e} diverso per i primi due tentativi. Il secondo errore \`{e} diverso perch\'{e} \textbf{if} \`{e} una parola riservata e Python ha notato questa parola e ha pensato che noi stessimo dicendo qualcosa, trovando per\`{o} la sintassi del costrutto non corretta.

Il modo corretto di dire {``}arrivederci'' a Python \`{e} scrivere \textbf{quit()} al  {\tt >>>}  prompt interattivo. Ci avresti messo un po' ad arrivarci da solo, quindi avere un libro a portata di mano ti \`{e} stato utile.


\section{Terminologia: interprete e compilatore}

Python \`{e} un linguaggio di \textbf{alto livello} pensato per essere scritto e letto in modo intuitivo dagli umani e facilmente letto e interpretato dai computers. Altri linguaggi ad alto livello sono: Java, C++, PHP, Ruby, Basic, Perl, JavaScript e molti altri. L'hardware contenuto nella CPU non \`{e} in grado di capire alcuno di questi linguaggi ad alto livello.


La CPU comprende un linguaggio che possiamo chiamare \textbf{linguaggio-macchina} . Il linguaggio-macchina \`{e} molto semplice e onestamente molto noioso da scrivere perch\'{e} \`{e} rappresentato solo da zeri e uno.

\beforeverb
\begin{verbatim}
01010001110100100101010000001111
11100110000011101010010101101101
...
\end{verbatim}
\afterverb
%
Il linguaggio macchina sembra molto semplice a prima vista poich\'{e} si tratta solo di zeri e uno, ma la sua sintassi \`{e} ancor pi\`{u} complicata e molto pi\`{u} intricata di quella di Python. Per questo motivo solo pochi programmatori usano il linguaggio macchina. Per facilitarci il compito si costruiscono diversi traduttori per consentire ai programmatori di scrivere usando linguaggi ad alto livello come Python o JavaScript e si lascia il compito a questi traduttori di convertire i programmi in linguaggio macchina per l'esecuzione in CPU.


Dal momento che il linguaggio macchina \`{e} legato all'hardware del computer, esso non \`{e} \textbf{portabile }su diversi tipi di hardware. Al contrario, i programmi scritti in linguaggi di alto livello possono essere usati su macchine diverse usando un interprete diverso sulla nuova macchina o ri-compilando il codice per creare una versione in linguaggio macchina compatibile con il nuovo hardware.


Questi traduttori di linguaggio di programmazione rientrano in due categorie generali: (1) interpreti e (2) compilatori.

Un \textbf{interprete }legge il codice sorgente di un programma come \`{e} stato scritto dal programmatore, lo passa al setaccio e interpreta le istruzioni al volo. Python \`{e} un interprete e quando eseguiamo Python in modalit\`{a} interattiva possiamo scrivere una riga di Python (una frase) e Python la processa immediatamente, rendendosi disponibile per un nostro nuovo input.


Alcune delle linee di Python dicono a Python che tu vuoi ricordare alcuni valori per un uso futuro. Abbiamo bisogno di scegliere un nome affinch\`{e} quel valore sia ricordato e sia possibile richiamarlo in seguito. Noi usiamo il termine variabile per indicare le etichette che usiamo per riferirci ai valori archiviati.

\beforeverb
\begin{verbatim}
>>> x = 6
>>> print x
6
>>> y = x * 7
>>> print y
42
>>> 
\end{verbatim}
\afterverb
%
In questo esempio chiediamo a Python di ricordare il valore 6 e di usare l'etichetta x cos\`{i} da poter recuperare il valore in seguito. Verifichiamo che Python abbia memorizzato il valore usando \textbf{print }. Chiediamo poi a Python di recuperare x e di moltiplicarlo per 7 e di salvare il risultato in y. Chiediamo infine a Python di stampare il valore corrente di y .


Anche se stiamo scrivendo queste istruzioni in Python una linea alla volta, Python le tratta come una sequenza ordinata di istruzioni in cui le ultime istruzioni sono in grado di recuperare i dati generati dalle istruzioni precedenti. Stiamo scrivendo il nostro primo semplice paragrafo con quattro frasi in un ordine logico e significativo.


E' nella natura di un interprete essere in grado di sostenere una conversazione interattiva come mostrato in precedenza. A un compilatore deve essere passato l'intero programma in un file e di seguito esso esegue il processo di traduzione del codice sorgente ad alto livello nel codice macchina e alla fine il compilatore restituisce un file con il codice macchina pronto per una futura esecuzione.


Se possiedi un sistema Windows, spesso questi programmi eseguibili in linguaggio macchina hanno un suffisso {``}.exe'' o {``}.dll'' che stanno rispettivamente per {``}eseguibile'' e {``}libreria caricabile dinamicamente''. In Linux e in Macintosh non ci sono suffissi che identificano chiaramente un file come eseguibile.


Se tu aprissi un file eseguibile con un editor di testo, esso sembrerebbe completamente confuso e illeggibile:

\beforeverb
\begin{verbatim}
^?ELF^A^A^A^@^@^@^@^@^@^@^@^@^B^@^C^@^A^@^@^@\xa0\x82
^D^H4^@^@^@\x90^]^@^@^@^@^@^@4^@ ^@^G^@(^@$^@!^@^F^@
^@^@4^@^@^@4\x80^D^H4\x80^D^H\xe0^@^@^@\xe0^@^@^@^E
^@^@^@^D^@^@^@^C^@^@^@^T^A^@^@^T\x81^D^H^T\x81^D^H^S
^@^@^@^S^@^@^@^D^@^@^@^A^@^@^@^A\^D^HQVhT\x83^D^H\xe8
....
\end{verbatim}
\afterverb
%
Non \`{e} facile leggere o scrivere linguaggio macchina, quindi \`{e} bello avere \textbf{interpreti }e \textbf{compilatori }che ci consentono di scrivere in un linguaggio ad alto livello come Python o C.


Ora, a questo punto della discussione su interpreti e compilatori, dovresti porti delle domande sull'interprete di Python. In quale linguaggio \`{e} scritto? E' scritto in un linguaggio compilato? Quando scriviamo Python cosa succede realmente?

L'interprete Python \`{e} scritto in un linguaggio ad alto livello chiamato {``}C''. Puoi sbirciare il codice sorgente dell'interprete di Python andando su  \url{www.python.org} e navigare fino al codice sorgente. In buona sostanza Python \`{e} un programma a sua volta e \`{e} compilato in codice macchina e quando lo installi sul tuo computer (o il rivenditore lo fa per te) tu copi nel tuo sistema una copia di codice macchina del programma Python tradotto. In Windows l'eseguibile per Python \`{e} molto probabilmente in un file con un nome simile a:

\beforeverb
\begin{verbatim}
C:\Python27\python.exe
\end{verbatim}
\afterverb
%
Digitare comandi nell'interprete Python \`{e} un gran bel modo per sperimentare le caratteristiche di questo linguaggio, ma non \`{e} consigliabile per affrontare problemi pi\`{u} complessi.


Quando vogliamo scrivere un programma, usiamo un editor di testo per scrivere istruzioni Python in un file, file che per definizione viene chiamato script. Per convenzione gli \textbf{script }di Python hanno nomi che finiscono con\textbf{ .py}


Per eseguire lo script, devi comunicare all'interprete di Python il nome del file. In una finestra di comando Unix o Windows , scriveresti python hello.py come segue:

\index{script}

\beforeverb
\begin{verbatim}
csev$ cat hello.py
print 'Hello world!'
csev$ python hello.py
Hello world!
csev$
\end{verbatim}
\afterverb
%
{``}csev\$'' \`{e} il prompt del sistema operativo e il comando cat hello.py ci mostra che il file hello.py contiene una linea di codice Python per stampare una stringa.


Invochiamo l'interprete Python e gli diciamo di leggere il codice sorgente dal file hello.py anzich\'{e} di richiederci i comandi in modo interattivo.


Nota che non c'\`{e} necessit\`{a} di scrivere quit() alla fine del programma Python contenuto nel file. Quando Python legge il tuo codice sorgente dal file, sa che deve fermarsi quando raggiunge la fine del file.

\section{Cos'\`{e} un programma?}

La definizione di un programma \`{e}, ai minimi termini, una sequenza di istruzioni Python che sono state assiemate per produrre un risultato. Anche il nostro semplice script hello.py \`{e} un programma. E' un programma di una sola riga e non particolarmente utile, ma \`{e} pur sempre un programma Python, stando alla definizione.


Potrebbe essere pi\`{u} semplice comprendere cos'\`{e} un programma pensando prima al problema che il programma dovrebbe risolvere e poi analizzando il programma stesso deputato a risolverlo.


Immaginiamo che tu stia facendo una ricerca in ambito Social Computing sui post di Facebook a tu sia interessato nelle parole pi\`{u} frequentemente usate in una serie di post. Potresti stampare il flusso di messaggi di Facebook e scorrere tutto il testo alla ricerca della parola pi\`{u} usata, ma sarebbe un lavoro molto lungo e darebbe adito facilmente ad errori. Faresti meglio a scrivere un programma in Python per gestire il compito velocemente e accuratamente cos\`{i} potresti trascorrere il weekend facendo qualcosa di divertente.


Per esempio osserva il seguente testo su un pagliaccio e un'auto in inglese. Guarda il testo e cerca di trovare la parola pi\`{u} usata e quante volte ricorre.


\beforeverb
\begin{verbatim}
the clown ran after the car and the car ran into the tent 
and the tent fell down on the clown and the car 
\end{verbatim}
\afterverb
%
mmaginati quindi di portare a termine questo compito per un milione di linee di testo. Onestamente sarebbe pi\`{u} veloce per te imparare Python e scrivere un programma in Python per contare le parole piuttosto che passare in rassegna tutte le parole.


La notizia ancora migliore \`{e} che ho gi\`{a} realizzato un semplice programma per trovare la parola pi\`{u} comune nel file di testo. L'ho scritto, l'ho testato e ora lo do a te cos\`{i} che tu possa risparmiare del tempo.

\beforeverb
\begin{verbatim}
name = raw_input('Enter file:')
handle = open(name, 'r')
text = handle.read()
words = text.split()
counts = dict()

for word in words:
   counts[word] = counts.get(word,0) + 1

bigcount = None
bigword = None
for word,count in counts.items():
    if bigcount is None or count > bigcount:
        bigword = word
        bigcount = count

print bigword, bigcount
\end{verbatim}
\afterverb
%
Non devi nemmeno conoscere Python per usare questo programma. Dovrai completare il capitolo 10 di questo libro per capire completamente le meravigliose tecniche Python che sono state usate per creare questo programma. Tu sei l'utente finale, tu semplicemente usi il programma e ti stupisci della sua bravura e di come ti ha risparmiato cos\`{i} tanto lavoro manuale. Tu semplicemente digiti il codice all'interno di un file chiamato \textbf{words.py} e lo esegui, o pi\`{u} semplicmente scarichi il file gi\`{a} bell'e pronto da \url{http://www.pythonlearn.com/code/} e lo esegui.

\index{program}
Questo \`{e} un buon esempio di come Python e il suo linguaggio agiscano da intermediari tra te (utente finale) e me (programmatore). Python \`{e} un modo per scambiarci utili sequenze di istruzioni (i.e. programmi) scritte in un linguaggio comune che possono essere utilizzate da chiunque installi Python sul suo computer. In questo modo nessuno di noi sta parlando a Python ma comunichiamo tra di noi tramite Python.

\section{Gli elementi costituenti di un programma}

Nei prossimi capitoli, approfondiremo il vocabolario, la sintassi, la struttura dei paragrafi e la struttura della storia di Python. Conosceremo le grandi potenzialit\`{a} di Python e il modo di integrare queste potenzialit\`{a} per creare programmi utili.


Ci sono alcuni schemi concettuali di basso livello che usiamo per costruire programmi. Questi costrutti non sono tipici solamente dei programmi Python ma sono parte di ogni linguaggio di programmazione, dal linguaggio macchina fino ai linguaggi di alto livello.

\begin{description}

\item[input:] Recupera dati dal {``}mondo esterno''. Questo potrebbe significare leggere dati da un file, o anche da qualche tipo di sensore come un microfono o un GPS. Nei nostri primi programmi, il nostro input verr\`{a} dall'utente che digita sulla tastiera.


\item[output:] Mostra i risultati di un'elaborazione su uno schermo o li archivia in un file o forse li invia ad una periferica come un altoparlante per riprodurre musica o leggere un testo.


\item[esecuzione sequenziale :] Controlla certe condizioni ed esegue o salta una sequenza di istruzioni.


\item[esecuzione condizionale:] Controlla certe condizioni ed esegue o salta una sequenza di istruzioni.


\item[resecuzione ripetuta :] Esegue alcuni set di istruzioni ripetutamente, solitamente con alcune variazioni

\item[riutilizzo:] Scrive un set di istruzioni una volta sola e gli assegna un nome e poi lo riusa al bisogno all'interno di un programma.

\end{description}

Sembra troppo bello per essere vero e infatti spesso le cose non sono cos\`{i} semplici. Sarebbe come dire che camminare \`{e} semplicemente {``}mettere un piede dopo l'altro''. L'arte di scrivere un programma risiede nel comporre e tessere assieme questi elementi di base pi\`{u} e pi\`{u} volte fino a produrre qualcosa di utile per gli utenti. 

Il programma di conta delle parole sopra riportato usa tutti questi schemi concettuali, tranne uno.

\section{Cosa potrebbe andare storto?}

Come abbiamo visto nelle nostre conversazioni iniziali con Python, dobbiamo essere molto precisi quando scriviamo codice Python. La pi\`{u} piccola deviazione o il pi\`{u} piccolo errore potrebbero causare l'interruzione dell'elaborazione.


I programmatori alle prime armi spesso vedono nel fatto che Python non lasci spazio ad errori come la prova che Python \`{e} malvagio, pieno di odio e crudele. Mentre Python sembra andare d'accordo con tutti gli altri, Python conosce questi novellini personalmente e prova del risentimento verso di loro. A causa di questo risentimento, Python prende programmi scritti alla perfezione e li rifiuta come {``}inadatti'' solo per tormentarli.

\beforeverb
\begin{verbatim}
>>> primt 'Hello world!'
  File "<stdin>", line 1
    primt 'Hello world!'
                       ^
SyntaxError: invalid syntax
>>> primt 'Hello world'
  File "<stdin>", line 1
    primt 'Hello world'
                      ^
SyntaxError: invalid syntax
>>> I hate you Python!
  File "<stdin>", line 1
    I hate you Python!
         ^
SyntaxError: invalid syntax
>>> if you come out of there, I would teach you a lesson
  File "<stdin>", line 1
    if you come out of there, I would teach you a lesson
              ^
SyntaxError: invalid syntax
>>> 
\end{verbatim}
\afterverb
%
C'\`{e} poco da guadagnare nel litigare con Python. E' uno strumento e non ha emozioni ed \`{e} felice e pronto a servirti ogniqualvolta tu ne abbia bisogno. I suoi messaggi di errore sembrano rudi, ma sono solo il modo di Python di chiedere aiuto. Python ha analizzato ci\`{o} che hai scritto e semplicemente non pu\`{o} capire cosa hai inserito.


Python assomiglia molto ad un cane, ti ama incondizionatamente, capisce solo poche parole, ti guarda con uno sguardo dolce  ({\tt >>>}), e aspetta che tu gli dica qualcosa che lui possa capire. Quando Python dice \emph{SyntaxError: invalid syntax} st\`{a} semplicemente muovendo la coda e dicendo {``}Ho visto che mi hai detto qualcosa ma io non lo capisco. Per favore continua a provarci  ({\tt >>>}).''

Man mano che i tuoi programmi diventano pi\`{u} sofisticati, incontrerai tre diversi tipi di errore:

\begin{description}

\item[Errori di sintassi (syntax error)] Questi sono i primi errori che farai e saranno i pi\`{u} facili da correggere. Un errore di sintassi significa che hai violato le regole {``}grammaticali'' di Python. Python fa il suo meglio per indicarti la linea e il punto in cui si \`{e} trovato in confusione. L'unico aspetto ingannevole degli errori di sintassi \`{e} che spesso l'errore st\`{a} a monte del punto indicato da Python. Per questo motivo il punto indicato da Python potrebbe essere solo il punto di partenza della tua indagine.


\item[Errori logici:] Un errore logico avviene quando il tuo programma ha una sintassi corretta ma c'\`{e} un errore nell'ordine degli enunciati o forse nell'ordine in cui gli enunciati si legano tra loro. Un buon esempio di errore logico potrebbe essere {``}prendi un sorso dalla tua bottiglia d'acqua, mettila nello zaino, vai in biblioteca e poi metti il tappo sulla bottiglia''.


\item[Errori semantici:] Un errore semantico accade quando la tua descrizione delle azioni da intraprendere \`{e} sintatticamente corretta e nel giusto ordine, ma c'\`{e} semplicemente un errore nel programma. Il programma \`{e} formalmente corretto ma non fa quello che tu vuoi che faccia. Un semplice esempio potrebbe essere questo: stai dando indicazioni ad una persona per raggiungere un ristorante e dici: {``}... quando raggiungi l'incrocio con il distributore di benzina, gira a sinistra e vai avanti per un miglio, il ristorante \`{e} l'edificio rosso alla tua sinistra''. Il tuo amico \`{e} molto in ritardo e ti chiama dicendo che \`{e} presso una fattoria e st\`{a} camminando attorno ad un fienile e del ristorante non c'\`{e} nemmeno l'ombra. Gli chiedi quindi {``}Hai girato a destra o a sinistra al distributore di benzina?'' e lui ti risponde {``}Ho seguito le tue istruzioni alla lettera, le ho scritte, dovevo girare a sinistra e proseguire per un miglio al distributore di benzina''. A questo punto tu dici {``}Mi dispiace, perch\'{e} anche se le mie istruzioni erano sintatticamente corrette, purtroppo esse contenevano un piccolo ma poco evidente errore semantico''.

\end{description}

In tutti i tre tipi di errore, Python sta semplicemente tentando di fare il suo meglio per fare esattamente cosa tu gli hai chiesto di fare.

\section{Il viaggio dell'apprendimento}

Nel leggere questo libro non preoccuparti se alcuni concetti non sembrano quadrare al primo impatto. Quando hai iniziato a parlare, non era un problema per i primi anni emettere solamente dei gorgoglii. Ed \`{e} stato normale impiegare sei mesi per passare da un vocabolario semplice a delle frasi semplici, impiegare 5-6 anni per passare da frasi a paragrafi e spendere altri due anni per scrivere piccole storie complete da solo.

Noi vogliamo che tu apprenda Python molto pi\`{u} rapidamente, quindi te lo presenteremo tutto assieme nei prossimi capitoli. E' per\`{o} il processo di apprendere una nuova lingua che richiede tempo per essere assimilato e compreso prima che tutto sembri naturale. Questo porta ad alcuni fraintendimenti nel vedere e rivedere gli argomenti nel tentativo di farti apprezzare l'insieme mentre definiamo i minuscoli frammenti che compongono il quadro generale. Anche se questo libro \`{e} stato scritto con un approccio lineare e tu stai seguendo un corso di formazione, non esitare a procedere in modo totalmente non-lineare quando ti avvicini alla materia. Guarda avanti, indietro, leggi senza scervellarti troppo. Sbirciando i contenuti pi\`{u} avanti in questo testo, pur non comprendendolo appieno, puoi capire meglio il perch\'{e} di alcune scelte di programmazione. Rivedendo il materiale gi\`{a} acquisito e rifacendo i vecchi esercizi ti renderai conto che hai imparato molto, anche se ci\`{o} che stai guardando adesso sembra impenetrabile.

Normalmente, quando si impara per la prima volta un linguaggio di programmazione, ci sono un paio di momenti {``}Ah-ah!'' in cui ti allontani dalla tua opera di martello e scalpello e vedi che stai realmente realizzando una bella scultura.

Se qualcosa sembra particolarmente difficile, non c'\`{e} solitamente ragione per passare la notte in bianco a fissarla. Fai una pausa, riposati, mangia qualcosa, spiega a qualcuno (o al tuo cane) perch\'{e} stai avendo un problema e poi torna a mente fresca. Ti assicuro che una volta che avrai appreso i concetti della programmazione esposti in questo libro, ti guarderai indietro e realizzerai che era tutto davvero semplice ed elegante e che ci \`{e} solamente voluto un po' di tempo per assimilarlo.

\section{Glossario}

\begin{description}

\item[bug/baco ( bug ):]  Un errore nel programma
\index{bug}
\index{baco}

\item[Central Processing Unit (CPU):] ( unit\`{a} di elaborazione centrale ) Il cuore di ogni computer. E' ci\`{o} che esegue il codice che scriviamo; si abbrevia in CPU e a volte la si indica come {``}il processore''.
\index{central processing unit}
\index{CPU}

\item[compilare  ( compile ):]  Tradurre un programma, scritto in un linguaggio ad alto livello, in linguaggio a basso livello, tutto in una volta, in preparazione ad una successiva esecuzione.
\index{compile}
\index{compilare}

\item[linguaggio di alto livello (high-level language):]  Un linguaggio di programmazione come Python che \`{e} progettato per essere facilmente letto e scritto dagli umani.
\index{high-level language}
\index{linguaggio ad alto livello}

\item[modalit\`{a} interattiva (interactive mode):] Un modo di usare l'interprete Python introducendo comandi ed espressioni al prompt.
\index{interactive mode}
\index{modo interattivo}

\item[interpretare (interpret):]  Eseguire un programma in un linguaggio ad alto livello traducendolo una riga alla volta.
\index{interpret}
\index{interprete}
\index{interpretare}

\item[linguaggio a basso livello (low-level language):]  Un linguaggio di programmazione che \`{e} disegnato per essere facilmente eseguibile da un computer: chiamato anche {``}codice macchina'' o {``}linguaggio assembly''.
\index{low-level language}
\index{linguaggio a basso livello}

\item[codice macchina (machine code):]  Il pi\`{u} basso livello per il software, che \`{e} anche il linguaggio eseguito dall'unit\`{a} di elaborazione centrale (CPU).
\index{machine code}
\index{codice macchina}

\item[memoria principale (main memory):] Archivia programmi e dati, ma perde le sue informazioni quando l'alimentazione \`{e} tolta.
\index{main memory}
\index{memoria principale}

\item[parse:]  (analizzare - valutare) Esaminare un programma e analizzare la struttura sintattica.
\index{parse}

\item[portabilit\`{a} (portability):]  La propriet\`{a} di un programma che pu\`{o} essere eseguito su pi\`{u} di un tipo di computer.
\index{portability}
\index{portabilit\`{a}}

\item[istruzione di stampa ( print statement ):]  Un'istruzione che fa s\`{i} che Python mostri a video un valore.
\index{print statement}
\index{statement!print}
\index{istruzione di stampa}
\index{stampa}

\item[problem solving:]  Il processo di formulare un problema, trovare una soluzione ed esprimerla.
\index{problem solving}

\item[programma:] Un insieme di istruzioni che identifica un'elaborazione.
\index{program}
\index{programma}

\item[prompt:] Quando un programma mostra un messaggio e attende che l'utente inserisca un dato per l'elaborazione.
\index{prompt}

\item[memoria secondaria (secondary memory):] Archivia programmi e dati e li conserva anche quand l'alimentazione \`{e} assente. Generalmente pi\`{u} lenta della memoria principale. Esempi della memoria secondaria sono dischi e memorie USB flash.
\index{secondary memory}
\index{memoria secondaria}

\item[semantica (semantics):]  Il significato di un programma.
\index{semantics}
\index{semantica}

\item[serrore semantico (semantic error):]   Un errore in un programma che gli fa fare qualcosa di diverso da ci\`{o} che il programmatore vuole.
\index{semantic error}
\index{errore semantico}

\item[codice sorgente (source code ):]  Un programma scritto in linguaggio ad alto livello.
\index{source code}
\index{codice sorgente}


\end{description}

\section{Esercizi}


\begin{ex}
Qual \`{e} la funzione della memoria secondaria in un computer?

a) Eseguire tutta i calcoli e la parte logica di un programma\\
b) Scaricare pagine web da internet\\
c) Archiviare informazioni a lungo termine, anche in assenza di alimentazione\\
d) Ricevere input dall'utente 
\end{ex}

\begin{ex}
Cos'\`{e} un programma?
\end{ex}

\begin{ex}
Qual \`{e} la differenza tra compilatore e interprete?
\end{ex}

\begin{ex}
Quale delle seguenti contiene codice macchina?

a) L'interprete Python\\
b) La tastiera\\
c) Il codice sorgente Python\\
d) Un documento di elaborazione testi
\end{ex}

\begin{ex}
Cosa c'\`{e} di sbagliato nel codice seguente:

\beforeverb
\begin{verbatim}
>>> primt 'Hello world!'
  File "<stdin>", line 1
    primt 'Hello world!'
                       ^
SyntaxError: invalid syntax
>>> 
\end{verbatim}
\afterverb

\end{ex}

\begin{ex}
Dove \`{e} archiviato il contenuto della variabile {``}X'' quando finisce la seguente istruzione Python?
\beforeverb
\begin{verbatim}
x = 123
\end{verbatim}
\afterverb
%
a) CPU\\
b) Memoria principale\
c) Memoria secondaria\\
d) Periferica di input\\
e) Periferica di output

\end{ex}

\begin{ex}
Cosa stampa questo codice Python?

\beforeverb
\begin{verbatim}
x = 43
x = x + 1
print x
\end{verbatim}
\afterverb
%
a) 43\\
b) 44\\
c) x + 1\\
d) Un errore perch\'{e} x = x+1 non \`{e} possibile matematicamente
\end{ex}

\begin{ex}
Spiega ciascuno dei seguenti elementi usando come esempio una caratteristica umana:
((1) CPU, (2) Memoria principale, (3) Memoria secondaria, (4) Dispositivo di input, (5) Dispositivo di output. Per esempio:Qual \`{e} l'equivalente umano della CPU?
\end{ex}

\begin{ex}
Come correggi un errore di sintassi?
\end{ex}

